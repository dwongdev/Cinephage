/**
 * PlaylistGenerator - Generates M3U playlists from user's channel lineup.
 * Creates playlists with proxy URLs for IPTV player consumption.
 */

import { getChannelLineupService } from '../lineup';
import type { PlaylistOptions } from './types';

/**
 * Escape special characters for M3U attribute values.
 */
function escapeAttr(value: string): string {
	return value.replace(/"/g, "'").replace(/\n/g, ' ');
}

class PlaylistGenerator {
	/**
	 * Generate M3U playlist from user's channel lineup.
	 * Returns a complete M3U file with proxied stream URLs.
	 */
	async generatePlaylist(options: PlaylistOptions): Promise<string> {
		const lineupService = getChannelLineupService();
		const lineup = await lineupService.getLineup();

		const lines: string[] = ['#EXTM3U'];

		if (lineup.length === 0) {
			return lines.join('\n');
		}

		for (const item of lineup) {
			// Build EXTINF attributes
			const attrs: string[] = [];

			// Use custom values with fallbacks to cached portal data
			const displayName = item.displayName || item.cachedName || 'Unknown Channel';
			const displayLogo = item.displayLogo || item.cachedLogo;

			// tvg-id for EPG matching - prefer user-set epgId, then displayName
			const epgId = item.epgId || displayName;
			attrs.push(`tvg-id="${escapeAttr(epgId)}"`);

			// Channel number (use position as fallback)
			if (options.includeChannelNumbers !== false) {
				const chno = item.channelNumber ?? item.position;
				attrs.push(`tvg-chno="${chno}"`);
			}

			// Group/category - prefer user category, fall back to portal category
			if (options.includeGroupTitles !== false) {
				const categoryName = item.category?.name || item.cachedCategoryName;
				if (categoryName) {
					attrs.push(`group-title="${escapeAttr(categoryName)}"`);
				}
			}

			// Logo - use custom logo if set, otherwise cached
			if (options.includeLogo !== false && displayLogo) {
				attrs.push(`tvg-logo="${escapeAttr(displayLogo)}"`);
			}

			// Build EXTINF line with display name
			const extinfLine = `#EXTINF:-1 ${attrs.join(' ')},${displayName}`;
			lines.push(extinfLine);

			// Stream URL (proxy endpoint)
			const streamUrl = `${options.baseUrl}/api/livetv/stream/${item.accountId}/${item.channelId}`;
			lines.push(streamUrl);
		}

		return lines.join('\n');
	}

	/**
	 * Get playlist as a formatted string with metadata header.
	 */
	async generatePlaylistWithHeader(options: PlaylistOptions): Promise<string> {
		const lineupService = getChannelLineupService();
		const count = await lineupService.getLineupCount();

		const playlist = await this.generatePlaylist(options);

		// Add metadata as comment at end
		return playlist + `\n# Generated by Cinephage - ${count} channels`;
	}
}

// Singleton instance
let instance: PlaylistGenerator | null = null;

export function getPlaylistGenerator(): PlaylistGenerator {
	if (!instance) {
		instance = new PlaylistGenerator();
	}
	return instance;
}

export type { PlaylistGenerator };
